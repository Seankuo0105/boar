<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no, maximum-scale=1.0">
    <title>3D 50層極限跑酷(手機版)</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #87CEEB; touch-action: none; font-family: Arial, sans-serif; user-select: none; -webkit-user-select: none; }
        
        #start-screen {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.8); color: white;
            display: flex; flex-direction: column; justify-content: center; align-items: center;
            z-index: 999;
        }
        #start-btn {
            padding: 15px 40px; font-size: 24px; background: #00ff00; border: none; border-radius: 10px; color: black; font-weight: bold; cursor: pointer;
        }
        
        #hud {
            position: absolute; top: 10px; left: 10px;
            color: #00ff00; font-size: 18px; font-weight: bold; text-shadow: 1px 1px 2px black;
            pointer-events: none; z-index: 10;
        }
        
        /* 手機操作介面 */
        .controls-hint {
            position: absolute; bottom: 50%; width: 100%; text-align: center; color: rgba(255,255,255,0.3); pointer-events: none; font-size: 14px;
        }
        #stick-area {
            position: absolute; top: 0; left: 0; width: 50%; height: 100%; z-index: 5;
        }
        #look-area {
            position: absolute; top: 0; right: 0; width: 50%; height: 100%; z-index: 5;
        }
        #jump-btn {
            position: absolute; bottom: 30px; right: 30px;
            width: 80px; height: 80px;
            background: rgba(255, 255, 255, 0.3);
            border: 2px solid white; border-radius: 50%;
            display: flex; justify-content: center; align-items: center;
            color: white; font-weight: bold; font-size: 16px;
            z-index: 20; touch-action: none;
        }
        #jump-btn:active { background: rgba(255, 255, 255, 0.6); }

        /* 虛擬搖桿視覺回饋 */
        .joystick-base {
            position: absolute; width: 100px; height: 100px; border-radius: 50%;
            background: rgba(255, 255, 255, 0.1); border: 1px solid rgba(255,255,255,0.3);
            display: none; pointer-events: none; transform: translate(-50%, -50%);
        }
        .joystick-stick {
            position: absolute; width: 40px; height: 40px; border-radius: 50%;
            background: rgba(255, 255, 255, 0.5); top: 50%; left: 50%;
            transform: translate(-50%, -50%); pointer-events: none;
        }
    </style>
</head>
<body>

    <div id="start-screen">
        <h1>3D 跑酷 (手機版)</h1>
        <p>左側移動 · 右側轉視角 · 按鈕跳躍</p>
        <button id="start-btn">點擊開始</button>
    </div>

    <div id="hud">檢查點: 0 / 50</div>
    
    <div id="joystick-ui" class="joystick-base">
        <div class="joystick-stick" id="joystick-knob"></div>
    </div>

    <div id="stick-area"></div>
    <div id="look-area"></div>
    <div id="jump-btn">跳躍</div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>

    <script>
        // 變數初始化
        let camera, scene, renderer;
        let velocity = new THREE.Vector3();
        let canJump = false;
        let prevTime = performance.now();
        
        // 移動相關變數
        let moveForward = 0, moveRight = 0;
        let touchStartX = 0, touchStartY = 0;
        let isMoving = false;
        
        // 視角相關變數
        let lookTouchId = null;
        let lastLookX = 0, lastLookY = 0;
        let pitch = 0, yaw = 0;

        // 遊戲邏輯變數
        const platforms = [];
        let currentCheckpoint = 0;
        const totalCheckpoints = 50;
        let respawnPoint = new THREE.Vector3(0, 10, 0);

        // 啟動按鈕
        const startBtn = document.getElementById('start-btn');
        const startScreen = document.getElementById('start-screen');

        startBtn.addEventListener('click', () => {
            startScreen.style.display = 'none';
            // 請求全螢幕
            if (document.documentElement.requestFullscreen) {
                document.documentElement.requestFullscreen();
            }
            init();
            animate();
        });

        function init() {
            // 場景
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x87CEEB);
            scene.fog = new THREE.Fog(0x87CEEB, 0, 750);

            // 相機
            camera = new THREE.PerspectiveCamera(70, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.rotation.order = 'YXZ'; // 確保 FPS 視角旋轉順序正確

            // 燈光
            const light = new THREE.HemisphereLight(0xffffff, 0x444444);
            light.position.set(0, 200, 0);
            scene.add(light);

            // 生成關卡
            generateLevel();

            // 渲染器
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setPixelRatio(window.devicePixelRatio);
            renderer.setSize(window.innerWidth, window.innerHeight);
            document.body.appendChild(renderer.domElement);

            // 重生
            resetPlayer();

            setupMobileControls();
            
            window.addEventListener('resize', onWindowResize);
        }

        // --- 手機控制邏輯 ---
        function setupMobileControls() {
            const stickArea = document.getElementById('stick-area');
            const lookArea = document.getElementById('look-area');
            const jumpBtn = document.getElementById('jump-btn');
            const joystickUi = document.getElementById('joystick-ui');
            const joystickKnob = document.getElementById('joystick-knob');

            // 1. 移動 (左半邊)
            stickArea.addEventListener('touchstart', (e) => {
                e.preventDefault();
                const touch = e.changedTouches[0];
                touchStartX = touch.clientX;
                touchStartY = touch.clientY;
                isMoving = true;

                // 顯示搖桿UI
                joystickUi.style.display = 'block';
                joystickUi.style.left = touchStartX + 'px';
                joystickUi.style.top = touchStartY + 'px';
                joystickKnob.style.transform = `translate(-50%, -50%)`;
            }, { passive: false });

            stickArea.addEventListener('touchmove', (e) => {
                if (!isMoving) return;
                e.preventDefault();
                const touch = e.changedTouches[0];
                
                const deltaX = touch.clientX - touchStartX;
                const deltaY = touch.clientY - touchStartY;
                
                // 限制搖桿範圍
                const distance = Math.sqrt(deltaX*deltaX + deltaY*deltaY);
                const maxDist = 40;
                
                let uiX = deltaX;
                let uiY = deltaY;

                if (distance > maxDist) {
                    const ratio = maxDist / distance;
                    uiX *= ratio;
                    uiY *= ratio;
                }

                // 更新 UI
                joystickKnob.style.transform = `translate(calc(-50% + ${uiX}px), calc(-50% + ${uiY}px))`;

                // 正規化速度 (-1 到 1)
                moveRight = Math.max(-1, Math.min(1, deltaX / 30)); 
                moveForward = -Math.max(-1, Math.min(1, deltaY / 30)); 
            }, { passive: false });

            const endMove = (e) => {
                e.preventDefault();
                isMoving = false;
                moveForward = 0;
                moveRight = 0;
                joystickUi.style.display = 'none';
            };
            stickArea.addEventListener('touchend', endMove);
            stickArea.addEventListener('touchcancel', endMove);

            // 2. 視角 (右半邊)
            lookArea.addEventListener('touchstart', (e) => {
                e.preventDefault();
                const touch = e.changedTouches[0];
                lookTouchId = touch.identifier;
                lastLookX = touch.clientX;
                lastLookY = touch.clientY;
            }, { passive: false });

            lookArea.addEventListener('touchmove', (e) => {
                e.preventDefault();
                for (let i = 0; i < e.changedTouches.length; i++) {
                    if (e.changedTouches[i].identifier === lookTouchId) {
                        const touch = e.changedTouches[i];
                        const movementX = touch.clientX - lastLookX;
                        const movementY = touch.clientY - lastLookY;

                        // 調整視角
                        yaw -= movementX * 0.005;
                        pitch -= movementY * 0.005;
                        
                        // 限制上下視角 (避免翻轉)
                        pitch = Math.max(-Math.PI / 2 + 0.1, Math.min(Math.PI / 2 - 0.1, pitch));

                        camera.rotation.x = pitch;
                        camera.rotation.y = yaw;

                        lastLookX = touch.clientX;
                        lastLookY = touch.clientY;
                    }
                }
            }, { passive: false });
            
            // 3. 跳躍
            jumpBtn.addEventListener('touchstart', (e) => {
                e.preventDefault();
                if (canJump) {
                    velocity.y += 300; // 手機版跳躍力道稍微調低適配操作
                    canJump = false;
                }
            }, { passive: false });
        }

        // --- 遊戲生成與邏輯 (與電腦版類似) ---
        function generateLevel() {
            createPlatform(0, 0, 0, 20, 0x555555, true); 
            let lastX = 0, lastY = 0, lastZ = -20;
            for (let i = 1; i <= totalCheckpoints; i++) {
                const gap = 15 + Math.random() * 8; // 手機版間距稍微縮短一點
                const xOffset = (Math.random() - 0.5) * 18;
                const yOffset = (Math.random() - 0.2) * 5; // 稍微容易一點的高度
                const nextX = lastX + xOffset;
                const nextY = lastY + yOffset;
                const nextZ = lastZ - gap;
                let color = (i === totalCheckpoints) ? 0xFFD700 : (i % 10 === 0 ? 0xFF0000 : 0x00ff00);
                let size = 12 - (i * 0.12); // 手機版平台稍微大一點點
                if (size < 5) size = 5;
                createPlatform(nextX, nextY, nextZ, size, color, false, i);
                lastX = nextX; lastY = nextY; lastZ = nextZ;
            }
        }

        function createPlatform(x, y, z, size, color, isStart, index) {
            const geometry = new THREE.BoxGeometry(size, 2, size);
            const material = new THREE.MeshLambertMaterial({ color: color });
            const platform = new THREE.Mesh(geometry, material);
            platform.position.set(x, y, z);
            platform.isPlatform = true;
            platform.checkpointIndex = index;
            scene.add(platform);
            platforms.push(platform);
        }

        function resetPlayer() {
            camera.position.copy(respawnPoint);
            camera.rotation.set(0, 0, 0);
            yaw = 0; pitch = 0;
            velocity.set(0, 0, 0);
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        const raycaster = new THREE.Raycaster(new THREE.Vector3(), new THREE.Vector3(0, -1, 0), 0, 10);

        function animate() {
            requestAnimationFrame(animate);

            const time = performance.now();
            const delta = Math.min((time - prevTime) / 1000, 0.1); // 限制最大delta防止卡頓穿牆

            // 物理與移動
            velocity.x -= velocity.x * 10.0 * delta;
            velocity.z -= velocity.z * 10.0 * delta;
            velocity.y -= 9.8 * 80.0 * delta; // 重力

            // 根據相機面向計算移動向量
            if (isMoving) {
                // 獲取相機的水平面向
                const forward = new THREE.Vector3(0, 0, -1).applyAxisAngle(new THREE.Vector3(0, 1, 0), yaw);
                const right = new THREE.Vector3(1, 0, 0).applyAxisAngle(new THREE.Vector3(0, 1, 0), yaw);
                
                velocity.add(forward.multiplyScalar(moveForward * 400 * delta));
                velocity.add(right.multiplyScalar(moveRight * 400 * delta));
            }

            // 碰撞檢測
            raycaster.ray.origin.copy(camera.position);
            raycaster.ray.origin.y -= 2; // 手機版視角稍微高一點
            const intersections = raycaster.intersectObjects(platforms);
            const onObject = intersections.length > 0;

            if (onObject === true) {
                velocity.y = Math.max(0, velocity.y);
                canJump = true;
                const hitPlatform = intersections[0].object;
                if (hitPlatform.checkpointIndex > currentCheckpoint) {
                    currentCheckpoint = hitPlatform.checkpointIndex;
                    document.getElementById('hud').innerText = `檢查點: ${currentCheckpoint} / ${totalCheckpoints}`;
                    respawnPoint.copy(hitPlatform.position);
                    respawnPoint.y += 5;
                    if (currentCheckpoint < totalCheckpoints) hitPlatform.material.color.setHex(0x0000ff); 
                    else alert("通關！");
                }
            }

            camera.position.x += velocity.x * delta;
            camera.position.z += velocity.z * delta;
            camera.position.y += velocity.y * delta;

            if (camera.position.y < -30) {
                velocity.set(0, 0, 0);
                camera.position.copy(respawnPoint);
            }

            prevTime = time;
            renderer.render(scene, camera);
        }
    </script>
</body>
</html>
