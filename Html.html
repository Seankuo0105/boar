<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <title>HTML 積木程式產生器</title>
    <script src="https://unpkg.com/blockly/blockly.min.js"></script>
    <style>
        body { display: flex; height: 100vh; margin: 0; font-family: sans-serif; }
        #blocklyDiv { height: 100%; width: 50%; }
        #outputArea { height: 100%; width: 50%; display: flex; flex-direction: column; border-left: 1px solid #ccc; }
        #codeArea { height: 40%; width: 100%; background: #f5f5f5; padding: 10px; box-sizing: border-box; overflow: auto; }
        #previewFrame { height: 60%; width: 100%; border: none; border-top: 1px solid #ccc; }
        h3 { margin: 5px 0; padding-left: 10px; background: #ddd; }
    </style>
</head>
<body>

<div id="blocklyDiv"></div>

<div id="outputArea">
    <h3>HTML 原始碼</h3>
    <textarea id="codeArea" readonly></textarea>
    <h3>網頁預覽</h3>
    <iframe id="previewFrame"></iframe>
</div>

<script>
    // --- A. 定義自定義積木 (Blocks) ---
    
    // 1. 基礎頁面結構積木
    Blockly.Blocks['html_page'] = {
      init: function() {
        this.appendDummyInput().appendField("網頁 (HTML)");
        this.appendStatementInput("CONTENT").setCheck(null);
        this.setColour(230);
        this.setTooltip("這是網頁的最外層");
      }
    };

    // 2. 標題積木 (H1)
    Blockly.Blocks['html_h1'] = {
      init: function() {
        this.appendDummyInput().appendField("大標題 (H1)");
        this.appendDummyInput().appendField(new Blockly.FieldTextInput("輸入標題文字"), "TEXT");
        this.setPreviousStatement(true, null); // 可以接在別的積木下面
        this.setNextStatement(true, null);     // 下面可以接別的積木
        this.setColour(160);
      }
    };

    // 3. 段落積木 (P)
    Blockly.Blocks['html_p'] = {
      init: function() {
        this.appendDummyInput().appendField("段落 (P)");
        this.appendDummyInput().appendField(new Blockly.FieldTextInput("輸入內文..."), "TEXT");
        this.setPreviousStatement(true, null);
        this.setNextStatement(true, null);
        this.setColour(120);
      }
    };

    // --- B. 定義代碼生成器 (Generator) ---
    // 我們創建一個簡單的生成器叫做 'HTML'
    const htmlGenerator = new Blockly.Generator('HTML');

    htmlGenerator['html_page'] = function(block) {
      var content = htmlGenerator.statementToCode(block, 'CONTENT');
      return '<!DOCTYPE html>\n<html>\n<body>\n' + content + '</body>\n</html>';
    };

    htmlGenerator['html_h1'] = function(block) {
      var text_value = block.getFieldValue('TEXT');
      return '<h1>' + text_value + '</h1>\n';
    };

    htmlGenerator['html_p'] = function(block) {
      var text_value = block.getFieldValue('TEXT');
      return '<p>' + text_value + '</p>\n';
    };

    htmlGenerator.scrub_ = function(block, code) {
      var nextBlock = block.nextConnection && block.nextConnection.targetBlock();
      var nextCode = htmlGenerator.blockToCode(nextBlock);
      return code + nextCode;
    };

    // --- C. 初始化 Blockly ---
    
    var workspace = Blockly.inject('blocklyDiv', {
      toolbox: {
        "kind": "flyoutToolbox", // 簡單的飛出式菜單
        "contents": [
          {"kind": "block", "type": "html_page"},
          {"kind": "block", "type": "html_h1"},
          {"kind": "block", "type": "html_p"}
        ]
      }
    });

    // --- D. 實時監聽與更新 ---
    function updateCode() {
      // 1. 生成代碼
      var code = htmlGenerator.workspaceToCode(workspace);
      // 2. 顯示代碼
      document.getElementById('codeArea').value = code;
      // 3. 更新 Iframe 預覽
      var iframe = document.getElementById('previewFrame');
      iframe.srcdoc = code;
    }

    workspace.addChangeListener(updateCode);
</script>

</body>
</html>
