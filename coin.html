<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    
    <title>硬幣遊戲</title>
    
    <link rel="icon" href="https://seankuo0105.github.io/boar/pig.png" type="image/png">

    <style>
        body { margin: 0; overflow: hidden; font-family: sans-serif; background-color: #000; }
        #loading-screen {
            position: absolute;
            top: 0; left: 0; width: 100%; height: 100%;
            background-color: #000;
            display: flex;
            justify-content: center;
            align-items: center;
            color: white;
            font-size: 24px;
            z-index: 100;
            transition: opacity 1.5s ease-out;
        }
        #loading-screen.fade-out { opacity: 0; pointer-events: none; }
        #ui {
            position: absolute;
            top: 20px;
            left: 20px;
            color: white;
            font-size: 24px;
            text-shadow: 2px 2px 4px #000;
            pointer-events: none;
        }
        #controls {
            position: absolute;
            bottom: 30px;
            width: 100%;
            display: flex;
            justify-content: center;
            gap: 20px; /* 按鈕之間的間距 */
            pointer-events: auto;
        }
        button {
            border: none;
            padding: 15px 30px;
            font-size: 18px;
            border-radius: 50px;
            cursor: pointer;
            color: white;
            box-shadow: 0 4px rgba(0,0,0,0.5);
            transition: transform 0.1s, box-shadow 0.1s;
        }
        button:active {
            transform: translateY(2px);
            box-shadow: 0 2px rgba(0,0,0,0.5);
        }
        #spawn-btn {
            background-color: #d62828; /* 紅色 */
        }
        #auto-btn {
            background-color: #555; /* 預設灰色 */
        }
        #auto-btn.active {
            background-color: #28a745; /* 啟動時變綠色 */
        }
    </style>
</head>
<body>

    <div id="loading-screen">Loading...</div>

    <div id="ui">
        分數: <span id="score">0</span>
    </div>
    <div id="controls">
        <button id="spawn-btn">手動掉幣</button>
        <button id="auto-btn">自動掉幣 (關)</button>
    </div>

    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/",
                "cannon-es": "https://unpkg.com/cannon-es@0.20.0/dist/cannon-es.js"
            }
        }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import * as CANNON from 'cannon-es';

        let scene, camera, renderer, world;
        let coins = [];
        let pusherBody, pusherMesh;
        let score = 0;
        const scoreElement = document.getElementById('score');
        let defaultMaterial;
        
        // 自動掉幣相關變數
        let autoDropEnabled = false;
        let lastAutoDropTime = 0;
        const autoDropInterval = 100; // 0.1秒 = 100毫秒
        
        const loadingManager = new THREE.LoadingManager();
        loadingManager.onLoad = () => {
            const loadingScreen = document.getElementById('loading-screen');
            loadingScreen.classList.add('fade-out');
        };

        init();
        animate();

        function init() {
            // --- Three.js 渲染場景 ---
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x222222);

            camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 100);
            camera.position.set(0, 15, 14);
            camera.lookAt(0, 0, 1);

            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            renderer.useLegacyLights = false;
            renderer.toneMapping = THREE.ACESFilmicToneMapping;
            renderer.toneMappingExposure = 1.0;
            document.body.appendChild(renderer.domElement);

            // --- 燈光調整 ---
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.8);
            scene.add(ambientLight);

            const hemiLight = new THREE.HemisphereLight(0xffffff, 0x444444, 1.2);
            hemiLight.position.set(0, 20, 0);
            scene.add(hemiLight);

            const dirLight = new THREE.DirectionalLight(0xffffff, 2.0);
            dirLight.position.set(5, 20, -10);
            dirLight.castShadow = true;
            dirLight.shadow.camera.top = 20; dirLight.shadow.camera.bottom = -20;
            dirLight.shadow.camera.left = -20; dirLight.shadow.camera.right = 20;
            dirLight.shadow.mapSize.width = 2048; dirLight.shadow.mapSize.height = 2048;
            scene.add(dirLight);

            const pointLight = new THREE.PointLight(0xffffff, 1.5, 50);
            pointLight.position.set(0, 15, 10); 
            scene.add(pointLight);

            // --- Cannon-es 物理世界 ---
            world = new CANNON.World();
            world.gravity.set(0, -18, 0);
            world.allowSleep = true;

            defaultMaterial = new CANNON.Material('default');
            const defaultContactMaterial = new CANNON.ContactMaterial(defaultMaterial, defaultMaterial, {
                friction: 0.3,
                restitution: 0.1
            });
            world.addContactMaterial(defaultContactMaterial);

            // --- 建立物件 ---
            createTrapezoidPlatform();
            createPusherWithBackWall(); 
            createWalls();

            // --- 按鈕事件綁定 ---
            // 1. 手動掉幣
            document.getElementById('spawn-btn').addEventListener('click', () => {
                spawnRandomCoin();
            });

            // 2. 自動掉幣開關
            const autoBtn = document.getElementById('auto-btn');
            autoBtn.addEventListener('click', () => {
                autoDropEnabled = !autoDropEnabled;
                if (autoDropEnabled) {
                    autoBtn.innerText = "自動掉幣 (開)";
                    autoBtn.classList.add('active');
                } else {
                    autoBtn.innerText = "自動掉幣 (關)";
                    autoBtn.classList.remove('active');
                }
            });
            
            window.addEventListener('resize', onWindowResize);
            loadingManager.onLoad();
        }

        function spawnRandomCoin() {
            const r = Math.random();
            const x = (Math.random() - 0.5) * 4;
            const y = 8;
            const z = -4.5;

            if (r < 0.65) {
                // 普通金幣
                createCoin(x, y, z, 0.6, 0.15, 10, 0xffd700, 0.7, 0.3);
            } else if (r < 0.90) {
                // 閃亮銀幣
                createCoin(x, y, z, 0.6, 0.15, 20, 0xeeeeff, 1.0, 0.01);
            } else {
                // 巨型金幣
                createCoin(x, y, z, 1.5, 0.3, 100, 0xffd700, 0.8, 0.2);
            }
        }

        function createTrapezoidShape(topWidth, bottomWidth, height, depth) {
            const tw = topWidth / 2, bw = bottomWidth / 2, h = height / 2, d = depth / 2;
            const vertices = [
                new CANNON.Vec3(-tw, h, -d), new CANNON.Vec3(tw, h, -d),
                new CANNON.Vec3(-bw, h,  d), new CANNON.Vec3(bw, h,  d),
                new CANNON.Vec3(-tw,-h, -d), new CANNON.Vec3(tw,-h, -d),
                new CANNON.Vec3(-bw,-h,  d), new CANNON.Vec3(bw,-h,  d)
            ];
            const faces = [[0, 2, 3, 1], [4, 5, 7, 6], [0, 1, 5, 4], [2, 6, 7, 3], [0, 4, 6, 2], [1, 3, 7, 5]];
            return new CANNON.ConvexPolyhedron({ vertices, faces });
        }
        function createTrapezoidMesh(topWidth, bottomWidth, height, depth, color) {
            const geometry = new THREE.BufferGeometry();
            const tw = topWidth / 2, bw = bottomWidth / 2, h = height / 2, d = depth / 2;
            const vertices = new Float32Array([
                -tw, h, -d,  tw, h, -d,  -bw, h, d,   tw, h, -d,   bw, h, d,  -bw, h, d,
                -bw, -h, d,   tw, -h, -d,  -tw, -h, -d,  bw, -h, d,   tw, -h, -d,  -bw, -h, d,
                -bw, h, d,   bw, h, d,  -bw, -h, d,   bw, h, d,   bw, -h, d,  -bw, -h, d,
                -tw, -h, -d,  tw, -h, -d,  -tw, h, -d,   tw, -h, -d,   tw, h, -d,  -tw, h, -d,
                -tw, h, -d,  -bw, h, d,  -tw, -h, -d,  -bw, h, d,  -bw, -h, d,  -tw, -h, -d,
                 bw, h, d,   tw, h, -d,   bw, -h, d,   tw, h, -d,   tw, -h, -d,   bw, -h, d
            ]);
            geometry.setAttribute('position', new THREE.BufferAttribute(vertices, 3));
            geometry.computeVertexNormals();
            const material = new THREE.MeshStandardMaterial({ color: color, metalness: 0.3, roughness: 0.6 });
            const mesh = new THREE.Mesh(geometry, material);
            mesh.receiveShadow = true; mesh.castShadow = true;
            return mesh;
        }

        function createTrapezoidPlatform() {
            const topW = 8, bottomW = 12, h = 1, d = 15;
            const mesh = createTrapezoidMesh(topW, bottomW, h, d, 0x555555);
            mesh.position.set(0, -0.5, 0);
            scene.add(mesh);
            const shape = createTrapezoidShape(topW, bottomW, h, d);
            const body = new CANNON.Body({ mass: 0, material: defaultMaterial });
            body.addShape(shape);
            body.position.copy(mesh.position);
            world.addBody(body);
        }

        function createPusherWithBackWall() {
            const topW = 8, bottomW = 8, h = 1.2, d = 4;
            const wallHeight = 2.5; 
            const wallThickness = 0.5; 
            const pusherColor = 0xcc3333;

            // 視覺
            pusherMesh = createTrapezoidMesh(topW, bottomW, h, d, pusherColor);
            const wallGeo = new THREE.BoxGeometry(topW, wallHeight, wallThickness);
            const wallMat = new THREE.MeshStandardMaterial({ color: pusherColor, metalness: 0.3, roughness: 0.6 });
            const backWallMesh = new THREE.Mesh(wallGeo, wallMat);
            backWallMesh.castShadow = true;
            backWallMesh.position.set(0, h/2 + wallHeight/2, -d/2 + wallThickness/2);
            pusherMesh.add(backWallMesh); 
            scene.add(pusherMesh);

            // 物理
            pusherBody = new CANNON.Body({ mass: 0, type: CANNON.Body.KINEMATIC, material: defaultMaterial });
            const baseShape = new CANNON.Box(new CANNON.Vec3(topW/2, h/2, d/2));
            pusherBody.addShape(baseShape); 
            const backWallShape = new CANNON.Box(new CANNON.Vec3(topW/2, wallHeight/2, wallThickness/2));
            const wallOffset = new CANNON.Vec3(0, h/2 + wallHeight/2, -d/2 + wallThickness/2);
            pusherBody.addShape(backWallShape, wallOffset);
            pusherBody.position.set(0, 0.6, -5.5);
            world.addBody(pusherBody);
        }

        function createWalls() {
            const wallMat = new THREE.MeshStandardMaterial({ color: 0xaaaaaa, transparent: true, opacity: 0.3, metalness: 0.2 });
            const wallPhysMat = new CANNON.Material();
            const meshL = new THREE.Mesh(new THREE.BoxGeometry(1, 4, 16), wallMat);
            meshL.position.set(-6, 1.5, 0); meshL.rotation.y = -0.15; scene.add(meshL);
            const bodyL = new CANNON.Body({ mass: 0, material: wallPhysMat });
            bodyL.addShape(new CANNON.Box(new CANNON.Vec3(0.5, 2, 8)));
            bodyL.position.copy(meshL.position); bodyL.quaternion.copy(meshL.quaternion); world.addBody(bodyL);
            const meshR = meshL.clone(); meshR.position.set(6, 1.5, 0); meshR.rotation.y = 0.15; scene.add(meshR);
            const bodyR = new CANNON.Body({ mass: 0, material: wallPhysMat });
            bodyR.addShape(new CANNON.Box(new CANNON.Vec3(0.5, 2, 8)));
            bodyR.position.copy(meshR.position); bodyR.quaternion.copy(meshR.quaternion); world.addBody(bodyR);
        }

        function createCoin(x, y, z, radius, height, coinScore, color, metalness, roughness) {
            const geo = new THREE.CylinderGeometry(radius, radius, height, 32); 
            const mat = new THREE.MeshStandardMaterial({ color, metalness, roughness });
            const mesh = new THREE.Mesh(geo, mat);
            mesh.castShadow = true;
            scene.add(mesh);

            const shape = new CANNON.Cylinder(radius, radius, height, 24);
            const body = new CANNON.Body({ mass: 2, material: defaultMaterial });
            const q = new CANNON.Quaternion();
            q.setFromAxisAngle(new CANNON.Vec3(1,0,0), -Math.PI/2);
            body.addShape(shape, new CANNON.Vec3(), q);
            body.position.set(x, y, z);
            body.quaternion.setFromAxisAngle(new CANNON.Vec3(1,0,0), Math.PI/2 + (Math.random()-0.5)*0.5);
            world.addBody(body);

            coins.push({ mesh, body, score: coinScore });
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        function animate() {
            requestAnimationFrame(animate);
            world.fixedStep();

            const now = Date.now();
            
            // --- 自動掉幣邏輯 ---
            if (autoDropEnabled && now - lastAutoDropTime > autoDropInterval) {
                spawnRandomCoin();
                lastAutoDropTime = now;
            }

            const time = now * 0.0008;
            pusherBody.position.z = -5.0 + Math.sin(time) * 2.0;
            pusherMesh.position.copy(pusherBody.position);

            for (let i = coins.length - 1; i >= 0; i--) {
                const coin = coins[i];
                coin.mesh.position.copy(coin.body.position);
                coin.mesh.quaternion.copy(coin.body.quaternion);
                coin.mesh.rotateX(-Math.PI/2);

                if (coin.body.position.y < -3) {
                    score += coin.score;
                    scoreElement.innerText = score;
                    world.removeBody(coin.body);
                    scene.remove(coin.mesh);
                    coins.splice(i, 1);
                }
            }
            renderer.render(scene, camera);
        }
    </script>
</body>
</html>
